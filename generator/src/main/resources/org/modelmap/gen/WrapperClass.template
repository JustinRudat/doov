package ${package.name};

import java.util.Iterator;
import java.util.Map;
import java.util.Map.Entry;
import java.util.function.BiConsumer;
import java.util.function.Function;

import javax.annotation.Generated;

import org.modelmap.core.FieldId;
import org.modelmap.core.FieldInfo;
import org.modelmap.core.FieldModel;
import ${target.field.info.package.name}.${target.field.info.class.name};

@Generated(value = "${source.generator.name}", comments="generated from ${process.class}")
public final class ${target.class.name} implements FieldModel {

    private final FieldInfo[] fieldInfos;
    private final ${target.model.class.name} model;

    public ${target.class.name}() {
        this(new ${target.model.class.name}());
    }

    public ${target.class.name}(${target.model.class.name} model) {
        this.fieldInfos = ${target.field.info.class.name}.values();
        this.model = model;
    }

    public ${target.model.class.name} getModel() {
        return model;
    }

    @Override
    public FieldInfo[] getFieldInfos() {
        return fieldInfos;
    }
    
    @Override
    public Iterator<Map.Entry<FieldId, Object>> iterator() {
        return new Iterator<Map.Entry<FieldId, Object>>() {
            int position = 0;

            @Override
            public boolean hasNext() {
                return position < fieldInfos.length;
            }

            @Override
            public Entry<FieldId, Object> next() {
                try {
                    return ${target.model.class.name}Property.values()[position].toEntry(model);
                } finally {
                    position++;
                }
            }
        };
    }

    @Override
    public <T> T get(FieldId fieldId) {
${map.getter.if}        return null;
    }

${map.getter}

    @Override
    public <T> void set(FieldId fieldId, T value) {
${map.setter.if}    }

${map.setter}

    @SuppressWarnings("unchecked")
    public static enum ${target.model.class.name}Property {
${map.properties}
        ;

        private final FieldId fieldId;
        private Map.Entry<FieldId, Object> entry;

        ${target.model.class.name}Property(FieldId fieldId) {
            this.fieldId = fieldId;
        }
        
        Map.Entry<FieldId, Object> toEntry(${target.model.class.name} model) {
            if (entry == null)
                synchronized (this) {
                    if (entry == null)
                        entry = new SupplierEntry<>(fieldId, model, supplier());
                }
            return entry;
        }

        public abstract <T> BiConsumer<${target.model.class.name}, T> consumer();

        public abstract <T> Function<${target.model.class.name}, T> supplier();
    }

    public static class SupplierEntry<M, T> implements Map.Entry<FieldId, Object> {
        final FieldId fieldId;
        final M model;
        final Function<M, T> supplier;

        SupplierEntry(FieldId fieldId, M model, Function<M, T> supplier) {
            super();
            this.fieldId = fieldId;
            this.model = model;
            this.supplier = supplier;
        }

        @Override
        public FieldId getKey() {
            return fieldId;
        }

        @Override
        public Object getValue() {
            return supplier.apply(model);
        }

        @Override
        public Object setValue(Object value) {
            throw new UnsupportedOperationException();
        }
    }
}